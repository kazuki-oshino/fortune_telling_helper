// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'output_info_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$OutputInfoStateTearOff {
  const _$OutputInfoStateTearOff();

  _OutputInfoState call(
      {Map<BloodType, TarotResult>? tarotResults,
      DateTime? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? typeADescription,
      String? typeBDescription,
      String? typeODescription,
      String? typeABDescription}) {
    return _OutputInfoState(
      tarotResults: tarotResults,
      targetDate: targetDate,
      firstBloodType: firstBloodType,
      secondBloodType: secondBloodType,
      thirdBloodType: thirdBloodType,
      fourthBloodType: fourthBloodType,
      typeADescription: typeADescription,
      typeBDescription: typeBDescription,
      typeODescription: typeODescription,
      typeABDescription: typeABDescription,
    );
  }
}

/// @nodoc
const $OutputInfoState = _$OutputInfoStateTearOff();

/// @nodoc
mixin _$OutputInfoState {
  Map<BloodType, TarotResult>? get tarotResults =>
      throw _privateConstructorUsedError;
  DateTime? get targetDate => throw _privateConstructorUsedError;
  String? get firstBloodType => throw _privateConstructorUsedError;
  String? get secondBloodType => throw _privateConstructorUsedError;
  String? get thirdBloodType => throw _privateConstructorUsedError;
  String? get fourthBloodType => throw _privateConstructorUsedError;
  String? get typeADescription => throw _privateConstructorUsedError;
  String? get typeBDescription => throw _privateConstructorUsedError;
  String? get typeODescription => throw _privateConstructorUsedError;
  String? get typeABDescription => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OutputInfoStateCopyWith<OutputInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutputInfoStateCopyWith<$Res> {
  factory $OutputInfoStateCopyWith(
          OutputInfoState value, $Res Function(OutputInfoState) then) =
      _$OutputInfoStateCopyWithImpl<$Res>;
  $Res call(
      {Map<BloodType, TarotResult>? tarotResults,
      DateTime? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? typeADescription,
      String? typeBDescription,
      String? typeODescription,
      String? typeABDescription});
}

/// @nodoc
class _$OutputInfoStateCopyWithImpl<$Res>
    implements $OutputInfoStateCopyWith<$Res> {
  _$OutputInfoStateCopyWithImpl(this._value, this._then);

  final OutputInfoState _value;
  // ignore: unused_field
  final $Res Function(OutputInfoState) _then;

  @override
  $Res call({
    Object? tarotResults = freezed,
    Object? targetDate = freezed,
    Object? firstBloodType = freezed,
    Object? secondBloodType = freezed,
    Object? thirdBloodType = freezed,
    Object? fourthBloodType = freezed,
    Object? typeADescription = freezed,
    Object? typeBDescription = freezed,
    Object? typeODescription = freezed,
    Object? typeABDescription = freezed,
  }) {
    return _then(_value.copyWith(
      tarotResults: tarotResults == freezed
          ? _value.tarotResults
          : tarotResults // ignore: cast_nullable_to_non_nullable
              as Map<BloodType, TarotResult>?,
      targetDate: targetDate == freezed
          ? _value.targetDate
          : targetDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstBloodType: firstBloodType == freezed
          ? _value.firstBloodType
          : firstBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      secondBloodType: secondBloodType == freezed
          ? _value.secondBloodType
          : secondBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdBloodType: thirdBloodType == freezed
          ? _value.thirdBloodType
          : thirdBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthBloodType: fourthBloodType == freezed
          ? _value.fourthBloodType
          : fourthBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      typeADescription: typeADescription == freezed
          ? _value.typeADescription
          : typeADescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeBDescription: typeBDescription == freezed
          ? _value.typeBDescription
          : typeBDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeODescription: typeODescription == freezed
          ? _value.typeODescription
          : typeODescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeABDescription: typeABDescription == freezed
          ? _value.typeABDescription
          : typeABDescription // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$OutputInfoStateCopyWith<$Res>
    implements $OutputInfoStateCopyWith<$Res> {
  factory _$OutputInfoStateCopyWith(
          _OutputInfoState value, $Res Function(_OutputInfoState) then) =
      __$OutputInfoStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<BloodType, TarotResult>? tarotResults,
      DateTime? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? typeADescription,
      String? typeBDescription,
      String? typeODescription,
      String? typeABDescription});
}

/// @nodoc
class __$OutputInfoStateCopyWithImpl<$Res>
    extends _$OutputInfoStateCopyWithImpl<$Res>
    implements _$OutputInfoStateCopyWith<$Res> {
  __$OutputInfoStateCopyWithImpl(
      _OutputInfoState _value, $Res Function(_OutputInfoState) _then)
      : super(_value, (v) => _then(v as _OutputInfoState));

  @override
  _OutputInfoState get _value => super._value as _OutputInfoState;

  @override
  $Res call({
    Object? tarotResults = freezed,
    Object? targetDate = freezed,
    Object? firstBloodType = freezed,
    Object? secondBloodType = freezed,
    Object? thirdBloodType = freezed,
    Object? fourthBloodType = freezed,
    Object? typeADescription = freezed,
    Object? typeBDescription = freezed,
    Object? typeODescription = freezed,
    Object? typeABDescription = freezed,
  }) {
    return _then(_OutputInfoState(
      tarotResults: tarotResults == freezed
          ? _value.tarotResults
          : tarotResults // ignore: cast_nullable_to_non_nullable
              as Map<BloodType, TarotResult>?,
      targetDate: targetDate == freezed
          ? _value.targetDate
          : targetDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      firstBloodType: firstBloodType == freezed
          ? _value.firstBloodType
          : firstBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      secondBloodType: secondBloodType == freezed
          ? _value.secondBloodType
          : secondBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdBloodType: thirdBloodType == freezed
          ? _value.thirdBloodType
          : thirdBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthBloodType: fourthBloodType == freezed
          ? _value.fourthBloodType
          : fourthBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      typeADescription: typeADescription == freezed
          ? _value.typeADescription
          : typeADescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeBDescription: typeBDescription == freezed
          ? _value.typeBDescription
          : typeBDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeODescription: typeODescription == freezed
          ? _value.typeODescription
          : typeODescription // ignore: cast_nullable_to_non_nullable
              as String?,
      typeABDescription: typeABDescription == freezed
          ? _value.typeABDescription
          : typeABDescription // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_OutputInfoState
    with DiagnosticableTreeMixin
    implements _OutputInfoState {
  const _$_OutputInfoState(
      {this.tarotResults,
      this.targetDate,
      this.firstBloodType,
      this.secondBloodType,
      this.thirdBloodType,
      this.fourthBloodType,
      this.typeADescription,
      this.typeBDescription,
      this.typeODescription,
      this.typeABDescription});

  @override
  final Map<BloodType, TarotResult>? tarotResults;
  @override
  final DateTime? targetDate;
  @override
  final String? firstBloodType;
  @override
  final String? secondBloodType;
  @override
  final String? thirdBloodType;
  @override
  final String? fourthBloodType;
  @override
  final String? typeADescription;
  @override
  final String? typeBDescription;
  @override
  final String? typeODescription;
  @override
  final String? typeABDescription;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OutputInfoState(tarotResults: $tarotResults, targetDate: $targetDate, firstBloodType: $firstBloodType, secondBloodType: $secondBloodType, thirdBloodType: $thirdBloodType, fourthBloodType: $fourthBloodType, typeADescription: $typeADescription, typeBDescription: $typeBDescription, typeODescription: $typeODescription, typeABDescription: $typeABDescription)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OutputInfoState'))
      ..add(DiagnosticsProperty('tarotResults', tarotResults))
      ..add(DiagnosticsProperty('targetDate', targetDate))
      ..add(DiagnosticsProperty('firstBloodType', firstBloodType))
      ..add(DiagnosticsProperty('secondBloodType', secondBloodType))
      ..add(DiagnosticsProperty('thirdBloodType', thirdBloodType))
      ..add(DiagnosticsProperty('fourthBloodType', fourthBloodType))
      ..add(DiagnosticsProperty('typeADescription', typeADescription))
      ..add(DiagnosticsProperty('typeBDescription', typeBDescription))
      ..add(DiagnosticsProperty('typeODescription', typeODescription))
      ..add(DiagnosticsProperty('typeABDescription', typeABDescription));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _OutputInfoState &&
            (identical(other.tarotResults, tarotResults) ||
                const DeepCollectionEquality()
                    .equals(other.tarotResults, tarotResults)) &&
            (identical(other.targetDate, targetDate) ||
                const DeepCollectionEquality()
                    .equals(other.targetDate, targetDate)) &&
            (identical(other.firstBloodType, firstBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.firstBloodType, firstBloodType)) &&
            (identical(other.secondBloodType, secondBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.secondBloodType, secondBloodType)) &&
            (identical(other.thirdBloodType, thirdBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.thirdBloodType, thirdBloodType)) &&
            (identical(other.fourthBloodType, fourthBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.fourthBloodType, fourthBloodType)) &&
            (identical(other.typeADescription, typeADescription) ||
                const DeepCollectionEquality()
                    .equals(other.typeADescription, typeADescription)) &&
            (identical(other.typeBDescription, typeBDescription) ||
                const DeepCollectionEquality()
                    .equals(other.typeBDescription, typeBDescription)) &&
            (identical(other.typeODescription, typeODescription) ||
                const DeepCollectionEquality()
                    .equals(other.typeODescription, typeODescription)) &&
            (identical(other.typeABDescription, typeABDescription) ||
                const DeepCollectionEquality()
                    .equals(other.typeABDescription, typeABDescription)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(tarotResults) ^
      const DeepCollectionEquality().hash(targetDate) ^
      const DeepCollectionEquality().hash(firstBloodType) ^
      const DeepCollectionEquality().hash(secondBloodType) ^
      const DeepCollectionEquality().hash(thirdBloodType) ^
      const DeepCollectionEquality().hash(fourthBloodType) ^
      const DeepCollectionEquality().hash(typeADescription) ^
      const DeepCollectionEquality().hash(typeBDescription) ^
      const DeepCollectionEquality().hash(typeODescription) ^
      const DeepCollectionEquality().hash(typeABDescription);

  @JsonKey(ignore: true)
  @override
  _$OutputInfoStateCopyWith<_OutputInfoState> get copyWith =>
      __$OutputInfoStateCopyWithImpl<_OutputInfoState>(this, _$identity);
}

abstract class _OutputInfoState implements OutputInfoState {
  const factory _OutputInfoState(
      {Map<BloodType, TarotResult>? tarotResults,
      DateTime? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? typeADescription,
      String? typeBDescription,
      String? typeODescription,
      String? typeABDescription}) = _$_OutputInfoState;

  @override
  Map<BloodType, TarotResult>? get tarotResults =>
      throw _privateConstructorUsedError;
  @override
  DateTime? get targetDate => throw _privateConstructorUsedError;
  @override
  String? get firstBloodType => throw _privateConstructorUsedError;
  @override
  String? get secondBloodType => throw _privateConstructorUsedError;
  @override
  String? get thirdBloodType => throw _privateConstructorUsedError;
  @override
  String? get fourthBloodType => throw _privateConstructorUsedError;
  @override
  String? get typeADescription => throw _privateConstructorUsedError;
  @override
  String? get typeBDescription => throw _privateConstructorUsedError;
  @override
  String? get typeODescription => throw _privateConstructorUsedError;
  @override
  String? get typeABDescription => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$OutputInfoStateCopyWith<_OutputInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}
