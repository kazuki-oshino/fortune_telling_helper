// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'output_info_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$OutputInfoStateTearOff {
  const _$OutputInfoStateTearOff();

  _OutputInfoState call(
      {Map<BloodType, TarotResult>? tarotResults,
      String? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? firstDescription,
      String? secondDescription,
      String? thirdDescription,
      String? fourthDescription}) {
    return _OutputInfoState(
      tarotResults: tarotResults,
      targetDate: targetDate,
      firstBloodType: firstBloodType,
      secondBloodType: secondBloodType,
      thirdBloodType: thirdBloodType,
      fourthBloodType: fourthBloodType,
      firstDescription: firstDescription,
      secondDescription: secondDescription,
      thirdDescription: thirdDescription,
      fourthDescription: fourthDescription,
    );
  }
}

/// @nodoc
const $OutputInfoState = _$OutputInfoStateTearOff();

/// @nodoc
mixin _$OutputInfoState {
  Map<BloodType, TarotResult>? get tarotResults =>
      throw _privateConstructorUsedError;
  String? get targetDate => throw _privateConstructorUsedError;
  String? get firstBloodType => throw _privateConstructorUsedError;
  String? get secondBloodType => throw _privateConstructorUsedError;
  String? get thirdBloodType => throw _privateConstructorUsedError;
  String? get fourthBloodType => throw _privateConstructorUsedError;
  String? get firstDescription => throw _privateConstructorUsedError;
  String? get secondDescription => throw _privateConstructorUsedError;
  String? get thirdDescription => throw _privateConstructorUsedError;
  String? get fourthDescription => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $OutputInfoStateCopyWith<OutputInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutputInfoStateCopyWith<$Res> {
  factory $OutputInfoStateCopyWith(
          OutputInfoState value, $Res Function(OutputInfoState) then) =
      _$OutputInfoStateCopyWithImpl<$Res>;
  $Res call(
      {Map<BloodType, TarotResult>? tarotResults,
      String? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? firstDescription,
      String? secondDescription,
      String? thirdDescription,
      String? fourthDescription});
}

/// @nodoc
class _$OutputInfoStateCopyWithImpl<$Res>
    implements $OutputInfoStateCopyWith<$Res> {
  _$OutputInfoStateCopyWithImpl(this._value, this._then);

  final OutputInfoState _value;
  // ignore: unused_field
  final $Res Function(OutputInfoState) _then;

  @override
  $Res call({
    Object? tarotResults = freezed,
    Object? targetDate = freezed,
    Object? firstBloodType = freezed,
    Object? secondBloodType = freezed,
    Object? thirdBloodType = freezed,
    Object? fourthBloodType = freezed,
    Object? firstDescription = freezed,
    Object? secondDescription = freezed,
    Object? thirdDescription = freezed,
    Object? fourthDescription = freezed,
  }) {
    return _then(_value.copyWith(
      tarotResults: tarotResults == freezed
          ? _value.tarotResults
          : tarotResults // ignore: cast_nullable_to_non_nullable
              as Map<BloodType, TarotResult>?,
      targetDate: targetDate == freezed
          ? _value.targetDate
          : targetDate // ignore: cast_nullable_to_non_nullable
              as String?,
      firstBloodType: firstBloodType == freezed
          ? _value.firstBloodType
          : firstBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      secondBloodType: secondBloodType == freezed
          ? _value.secondBloodType
          : secondBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdBloodType: thirdBloodType == freezed
          ? _value.thirdBloodType
          : thirdBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthBloodType: fourthBloodType == freezed
          ? _value.fourthBloodType
          : fourthBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      firstDescription: firstDescription == freezed
          ? _value.firstDescription
          : firstDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      secondDescription: secondDescription == freezed
          ? _value.secondDescription
          : secondDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdDescription: thirdDescription == freezed
          ? _value.thirdDescription
          : thirdDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthDescription: fourthDescription == freezed
          ? _value.fourthDescription
          : fourthDescription // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$OutputInfoStateCopyWith<$Res>
    implements $OutputInfoStateCopyWith<$Res> {
  factory _$OutputInfoStateCopyWith(
          _OutputInfoState value, $Res Function(_OutputInfoState) then) =
      __$OutputInfoStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<BloodType, TarotResult>? tarotResults,
      String? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? firstDescription,
      String? secondDescription,
      String? thirdDescription,
      String? fourthDescription});
}

/// @nodoc
class __$OutputInfoStateCopyWithImpl<$Res>
    extends _$OutputInfoStateCopyWithImpl<$Res>
    implements _$OutputInfoStateCopyWith<$Res> {
  __$OutputInfoStateCopyWithImpl(
      _OutputInfoState _value, $Res Function(_OutputInfoState) _then)
      : super(_value, (v) => _then(v as _OutputInfoState));

  @override
  _OutputInfoState get _value => super._value as _OutputInfoState;

  @override
  $Res call({
    Object? tarotResults = freezed,
    Object? targetDate = freezed,
    Object? firstBloodType = freezed,
    Object? secondBloodType = freezed,
    Object? thirdBloodType = freezed,
    Object? fourthBloodType = freezed,
    Object? firstDescription = freezed,
    Object? secondDescription = freezed,
    Object? thirdDescription = freezed,
    Object? fourthDescription = freezed,
  }) {
    return _then(_OutputInfoState(
      tarotResults: tarotResults == freezed
          ? _value.tarotResults
          : tarotResults // ignore: cast_nullable_to_non_nullable
              as Map<BloodType, TarotResult>?,
      targetDate: targetDate == freezed
          ? _value.targetDate
          : targetDate // ignore: cast_nullable_to_non_nullable
              as String?,
      firstBloodType: firstBloodType == freezed
          ? _value.firstBloodType
          : firstBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      secondBloodType: secondBloodType == freezed
          ? _value.secondBloodType
          : secondBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdBloodType: thirdBloodType == freezed
          ? _value.thirdBloodType
          : thirdBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthBloodType: fourthBloodType == freezed
          ? _value.fourthBloodType
          : fourthBloodType // ignore: cast_nullable_to_non_nullable
              as String?,
      firstDescription: firstDescription == freezed
          ? _value.firstDescription
          : firstDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      secondDescription: secondDescription == freezed
          ? _value.secondDescription
          : secondDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      thirdDescription: thirdDescription == freezed
          ? _value.thirdDescription
          : thirdDescription // ignore: cast_nullable_to_non_nullable
              as String?,
      fourthDescription: fourthDescription == freezed
          ? _value.fourthDescription
          : fourthDescription // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_OutputInfoState
    with DiagnosticableTreeMixin
    implements _OutputInfoState {
  const _$_OutputInfoState(
      {this.tarotResults,
      this.targetDate,
      this.firstBloodType,
      this.secondBloodType,
      this.thirdBloodType,
      this.fourthBloodType,
      this.firstDescription,
      this.secondDescription,
      this.thirdDescription,
      this.fourthDescription});

  @override
  final Map<BloodType, TarotResult>? tarotResults;
  @override
  final String? targetDate;
  @override
  final String? firstBloodType;
  @override
  final String? secondBloodType;
  @override
  final String? thirdBloodType;
  @override
  final String? fourthBloodType;
  @override
  final String? firstDescription;
  @override
  final String? secondDescription;
  @override
  final String? thirdDescription;
  @override
  final String? fourthDescription;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OutputInfoState(tarotResults: $tarotResults, targetDate: $targetDate, firstBloodType: $firstBloodType, secondBloodType: $secondBloodType, thirdBloodType: $thirdBloodType, fourthBloodType: $fourthBloodType, firstDescription: $firstDescription, secondDescription: $secondDescription, thirdDescription: $thirdDescription, fourthDescription: $fourthDescription)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OutputInfoState'))
      ..add(DiagnosticsProperty('tarotResults', tarotResults))
      ..add(DiagnosticsProperty('targetDate', targetDate))
      ..add(DiagnosticsProperty('firstBloodType', firstBloodType))
      ..add(DiagnosticsProperty('secondBloodType', secondBloodType))
      ..add(DiagnosticsProperty('thirdBloodType', thirdBloodType))
      ..add(DiagnosticsProperty('fourthBloodType', fourthBloodType))
      ..add(DiagnosticsProperty('firstDescription', firstDescription))
      ..add(DiagnosticsProperty('secondDescription', secondDescription))
      ..add(DiagnosticsProperty('thirdDescription', thirdDescription))
      ..add(DiagnosticsProperty('fourthDescription', fourthDescription));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _OutputInfoState &&
            (identical(other.tarotResults, tarotResults) ||
                const DeepCollectionEquality()
                    .equals(other.tarotResults, tarotResults)) &&
            (identical(other.targetDate, targetDate) ||
                const DeepCollectionEquality()
                    .equals(other.targetDate, targetDate)) &&
            (identical(other.firstBloodType, firstBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.firstBloodType, firstBloodType)) &&
            (identical(other.secondBloodType, secondBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.secondBloodType, secondBloodType)) &&
            (identical(other.thirdBloodType, thirdBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.thirdBloodType, thirdBloodType)) &&
            (identical(other.fourthBloodType, fourthBloodType) ||
                const DeepCollectionEquality()
                    .equals(other.fourthBloodType, fourthBloodType)) &&
            (identical(other.firstDescription, firstDescription) ||
                const DeepCollectionEquality()
                    .equals(other.firstDescription, firstDescription)) &&
            (identical(other.secondDescription, secondDescription) ||
                const DeepCollectionEquality()
                    .equals(other.secondDescription, secondDescription)) &&
            (identical(other.thirdDescription, thirdDescription) ||
                const DeepCollectionEquality()
                    .equals(other.thirdDescription, thirdDescription)) &&
            (identical(other.fourthDescription, fourthDescription) ||
                const DeepCollectionEquality()
                    .equals(other.fourthDescription, fourthDescription)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(tarotResults) ^
      const DeepCollectionEquality().hash(targetDate) ^
      const DeepCollectionEquality().hash(firstBloodType) ^
      const DeepCollectionEquality().hash(secondBloodType) ^
      const DeepCollectionEquality().hash(thirdBloodType) ^
      const DeepCollectionEquality().hash(fourthBloodType) ^
      const DeepCollectionEquality().hash(firstDescription) ^
      const DeepCollectionEquality().hash(secondDescription) ^
      const DeepCollectionEquality().hash(thirdDescription) ^
      const DeepCollectionEquality().hash(fourthDescription);

  @JsonKey(ignore: true)
  @override
  _$OutputInfoStateCopyWith<_OutputInfoState> get copyWith =>
      __$OutputInfoStateCopyWithImpl<_OutputInfoState>(this, _$identity);
}

abstract class _OutputInfoState implements OutputInfoState {
  const factory _OutputInfoState(
      {Map<BloodType, TarotResult>? tarotResults,
      String? targetDate,
      String? firstBloodType,
      String? secondBloodType,
      String? thirdBloodType,
      String? fourthBloodType,
      String? firstDescription,
      String? secondDescription,
      String? thirdDescription,
      String? fourthDescription}) = _$_OutputInfoState;

  @override
  Map<BloodType, TarotResult>? get tarotResults =>
      throw _privateConstructorUsedError;
  @override
  String? get targetDate => throw _privateConstructorUsedError;
  @override
  String? get firstBloodType => throw _privateConstructorUsedError;
  @override
  String? get secondBloodType => throw _privateConstructorUsedError;
  @override
  String? get thirdBloodType => throw _privateConstructorUsedError;
  @override
  String? get fourthBloodType => throw _privateConstructorUsedError;
  @override
  String? get firstDescription => throw _privateConstructorUsedError;
  @override
  String? get secondDescription => throw _privateConstructorUsedError;
  @override
  String? get thirdDescription => throw _privateConstructorUsedError;
  @override
  String? get fourthDescription => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$OutputInfoStateCopyWith<_OutputInfoState> get copyWith =>
      throw _privateConstructorUsedError;
}
